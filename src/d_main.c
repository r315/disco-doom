// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------


static const char rcsid[] = "$Id: d_main.c,v 1.8 1997/02/03 22:45:09 b1 Exp $";

#include <stdio.h>
#include <stdlib.h>

#define	BGCOLOR		7
#define	FGCOLOR		8
#define R_OK        4

#define MAX_PATH_SIZE   64

extern int access(char *file, int mode);

#if 0
static int access(char *file, int mode)
{
	FILE *test_fp;
	test_fp = fopen(file, "r");
	if ( test_fp != NULL ) {
		fclose(test_fp);
		return(0);
	}
	return(-1);
}
#endif

#include "doomdef.h"
#include "doomstat.h"

#include "dstrings.h"
#include "sounds.h"


#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "v_video.h"

#include "f_finale.h"
#include "f_wipe.h"

#include "common.h"
#include "m_misc.h"
#include "m_menu.h"

#include "i_system.h"
#include "i_sound.h"
#include "i_video.h"

#include "g_game.h"

#include "hu_stuff.h"
#include "wi_stuff.h"
#include "st_stuff.h"
#include "am_map.h"

#include "p_setup.h"
#include "r_local.h"

#include "d_main.h"


boolean d_devparm;		// started game with -devparm
boolean nomonsters;     // checkparm of -nomonsters
boolean respawnparm;	// checkparm of -respawn
boolean fastparm;		// checkparm of -fast

//boolean drone;

boolean singletics = false; // debug flag to cancel adaptiveness

//extern int soundVolume;
//extern  int	sfxVolume;
//extern  int	musicVolume;

extern boolean	inhelpscreens;

skill_t startskill;
int startepisode;
int startmap;
boolean autostart;

FILE*	debugfile;
static char *wadfilename;
static char *basedir;

boolean advancedemo;

char mapdir[1024];      // directory of development maps
char basedefault[1024]; // default file

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t events[MAXEVENTS];
int eventhead;
int eventtail;

//
//  DEMO LOOP
//
static int  d_demosequence;
static int  d_pagetic;
static char *d_pagename;

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t wipegamestate = GS_DEMOSCREEN;
extern boolean setsizeneeded;
extern int             showMessages;

const char *d_wadnames[] = {
        "doom.wad",     // Registered
        "doom1.wad",    // Shareware
        "doomu.wad",    // Retail
        "doom2.wad",    // Comercial
};

//
// D-DoomLoop()
// Not a globally visible function,
//  just included for source reference,
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls I_GetTime, I_StartFrame, and I_StartTic
//
void D_DoomLoop (void);
void D_CheckNetGame (void);
void D_ProcessEvents (void);
void G_BuildTiccmd (ticcmd_t* cmd);
void R_ExecuteSetViewSize (void);

//==============================================================================
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent (event_t* ev)
{
    events[eventhead++] = *ev;
    eventhead = eventhead&(MAXEVENTS-1);
}


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents (void)
{
    event_t*	ev;
	
    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if ( ( gamemode == commercial ) && (W_CheckNumForName("map01")<0) )
      return;
	
    for ( ; eventtail != eventhead; )
    {
        ev = &events[eventtail++];
        if (M_Responder (ev))
            continue;               // menu ate the event
        G_Responder (ev);
        eventtail = eventtail & (MAXEVENTS-1);
    }
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

void D_Display (void)
{
    static  boolean		viewactivestate = false;
    static  boolean		menuactivestate = false;
    static  boolean		inhelpscreensstate = false;
    static  boolean		fullscreen = false;
    static  gamestate_t		oldgamestate = -1;
    static  int			borderdrawcount;
    int				nowtime;
    int				tics;
    int				wipestart;
    int				y;
    boolean			done;
    boolean			wipe;
    boolean			redrawsbar;

    if (nodrawers)
	   return;                  // for comparative timing / profiling
		
    redrawsbar = false;
    
    // change the view size if needed
    if (setsizeneeded)
    {
    	R_ExecuteSetViewSize ();
        oldgamestate = -1;                      // force background redraw
    	borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    if (gamestate != wipegamestate)
    {
    	wipe = true;
    	wipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);
    }
    else
	   wipe = false;

    if (gamestate == GS_LEVEL && gametic)
    	HU_Erase();
    
    // do buffered drawing
    switch (gamestate)
    {
      case GS_LEVEL:
            if (!gametic)
	           break;
            if (automapactive)
                AM_Drawer ();
            if (wipe || (viewheight != 200 && fullscreen) )
        	    redrawsbar = true;
        	if (inhelpscreensstate && !inhelpscreens)
        	    redrawsbar = true;              // just put away the help screen
        	ST_Drawer (viewheight == 200, redrawsbar );
           	fullscreen = viewheight == 200;
        	break;

      case GS_INTERMISSION:
        	WI_Drawer ();
        	break;

      case GS_FINALE:
        	F_Drawer ();
        	break;

      case GS_DEMOSCREEN:
        	D_PageDrawer ();
        	break;
    }
    
    // draw buffered stuff to screen
    //I_UpdateNoBlit ();
    
    // draw the view directly
    if (gamestate == GS_LEVEL && !automapactive && gametic)
	   R_RenderPlayerView (&players[displayplayer]);

    if (gamestate == GS_LEVEL && gametic)
    	HU_Drawer ();
    
    // clean up border stuff
    if (gamestate != oldgamestate && gamestate != GS_LEVEL)
	   I_SetPalette (W_CacheLumpName ("PLAYPAL",PU_CACHE));

    // see if the border needs to be initially drawn
    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)
    {
    	viewactivestate = false;        // view was not active
        R_FillBackScreen ();    // draw the pattern into the back screen
    }

    // see if the border needs to be updated to the screen
    if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)
    {
    	if (menuactive || menuactivestate || !viewactivestate)
	       borderdrawcount = 3;
    	if (borderdrawcount)
	    {
	       R_DrawViewBorder ();    // erase old menu stuff
	       borderdrawcount--;
	    }

    }

    menuactivestate = menuactive;
    viewactivestate = viewactive;
    inhelpscreensstate = inhelpscreens;
    oldgamestate = wipegamestate = gamestate;
    
    // draw pause pic
    if (paused)
    {
	   if (automapactive)
	        y = 4;
	   else
	       y = viewwindowy+4;
	   V_DrawPatchDirect(viewwindowx+(scaledviewwidth-68)/2,
	   y,0,W_CacheLumpName ("M_PAUSE", PU_CACHE));
    }


    // menus go directly to the screen
    M_Drawer ();          // menu is drawn even on top of everything
    NetUpdate ();         // send out any new accumulation


    // normal update
    if (!wipe)
    {
	   I_FinishUpdate ();              // page flip or blit buffer
    	return;
    }
    
    // wipe update
    wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

    wipestart = I_GetTime () - 1;

    do
    {
	   do
	   {
	       nowtime = I_GetTime ();
	       tics = nowtime - wipestart;
	   } while (!tics);
	   wipestart = nowtime;
	   done = wipe_ScreenWipe(wipe_Melt
			       , 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);
	   I_UpdateNoBlit ();
	   M_Drawer ();                            // menu is drawn even on top of wipes
	   I_FinishUpdate ();                      // page flip or blit buffer
    } while (!done);
}



//-------------------------------------------------------------
//  D_DoomLoop
//-------------------------------------------------------------
//extern  boolean         demorecording;

void D_DoomLoop (void)
{
#if 0
	if (COM_CheckParm ("-debugfile"))
    {
        char    filename[20];
        sprintf (filename,"debug%i.txt",consoleplayer);
        printf ("debug output to: %s\n",filename);
    	debugfile = fopen (filename,"w");
    }
#endif
   
    eventhead = eventtail = 0;

    while (1)
    {    	
    	// process one or more tics
        if (singletics)
        {
			printf("singleticks");
            I_StartTic ();
            D_ProcessEvents ();
            G_BuildTiccmd (&netcmds[consoleplayer][maketic%BACKUPTICS]);
            if (advancedemo)
                D_DoAdvanceDemo ();
            M_Ticker ();
            G_Ticker ();
            gametic++;
            maketic++;
            break;
        }
		else 
		{
			TryRunTics(); // will run at least one tic		
		}

		S_UpdateSounds (players[consoleplayer].mo);// move positional sounds

    	// Update display, next frame, with current state.
	    D_Display ();
    }
}

//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker (void)
{
    if (--d_pagetic < 0)
	   D_AdvanceDemo ();
}



//
// D_PageDrawer
//
void D_PageDrawer (void)
{
    V_DrawPatch (0,0, 0, W_CacheLumpName(d_pagename, PU_CACHE));
}


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo (void)
{
    advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
void D_DoAdvanceDemo (void)
{
    players[consoleplayer].playerstate = PST_LIVE;  // not reborn
    advancedemo = false;
    usergame = false;               // no save / end game here
    paused = false;
    gameaction = ga_nothing;

    if ( gamemode == retail )
      d_demosequence = (d_demosequence+1)%7;
    else
      d_demosequence = (d_demosequence+1)%6;
    
    switch (d_demosequence)
    {
		case 0:
            if ( gamemode == commercial )
                d_pagetic = 35 * 11;
        	else
                d_pagetic = 170;
                
            gamestate = GS_DEMOSCREEN;
			d_pagename = "TITLEPIC";
            if ( gamemode == commercial )
                S_StartMusic(mus_dm2ttl);
        	else
                S_StartMusic (mus_intro);
            break;
            
        case 1:	G_DeferedPlayDemo ("demo1");	break;
      
        case 2:
            d_pagetic = 200;
        	gamestate = GS_DEMOSCREEN;
        	d_pagename = "CREDIT";
        	break;
        	
        case 3:	G_DeferedPlayDemo ("demo2");	break;
        
        case 4:	gamestate = GS_DEMOSCREEN;
            if ( gamemode == commercial)
        	{
	            d_pagetic = 35 * 11;
                d_pagename = "TITLEPIC";
	            S_StartMusic(mus_dm2ttl);
            }
            else
            {
                d_pagetic = 200;
                if ( gamemode == retail )
                    d_pagename = "CREDIT";
        	    else if(gamemode == registered)
	                d_pagename = "HELP1";
				else if (gamemode == shareware)
					d_pagename = "HELP2";
	       }
           break;
           
        case 5:	G_DeferedPlayDemo ("demo3");	break;
      
        // THE DEFINITIVE DOOM Special Edition demo
        case 6:   G_DeferedPlayDemo ("demo4");    break;
    }
}



//
// D_StartTitle
//
void D_StartTitle (void)
{
    gameaction = ga_nothing;
    d_demosequence = -1;
    D_AdvanceDemo ();
}

char *D_GetFilename(char *path)
{
	char *ptr = path + strlen(path); // start from end

	while (ptr != path) {
#ifdef _WIN32
		if (*ptr == '/' || *ptr == '\\') {
#else
		if (*ptr == '/') {
#endif
			return ptr + 1;
		}
		ptr--;
	}
	return ptr;
}
/**

*/
static GameMode_t D_CheckWadFile(char *wadname) {
    
    if(wadname == NULL || *wadname == '\0'){
        return indetermined;
    }
    
	// Test access to file    
	if (!access(wadname, R_OK)) {
		COM_Print("Using %s\n", wadname);
		char *name = D_GetFilename(wadname);
        if(!strcmp(name, "doom1.wad")){
            return shareware; 
        }

        if(!strcmp(name, "doom.wad")){
            return registered; 
        }

        if(!strcmp(name, "doomu.wad")){
            return retail; 
        }

        if(!strcmp(name, "doom2.wad")){
            return commercial; 
        }
	}

	return indetermined;
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
static GameMode_t D_IDVersion (void)
{

    wadfilename = (char*)calloc(1, MAX_PATH_SIZE);
    GameMode_t gm;

    if(!wadfilename){
        // Fail t allocate
        return indetermined;
    }
    
    // check for given wad file
    char *wadfile_param = COM_GetParm("-wadfile");
    if(wadfile_param){   
        sprintf(wadfilename, "%s/%s", basedir, wadfile_param);
        gm = D_CheckWadFile(wadfilename);
        if (gm != indetermined) {
            return gm;   
        }
    }

    // Check if forced shareware
    if (COM_CheckParm ("-shdev"))
    {
	    d_devparm = true;
	    //D_AddFile (DEVDATA"doom1.wad");
	    //D_AddFile (DEVMAPS"data_se/texture1.lmp");
	    //D_AddFile (DEVMAPS"data_se/pnames.lmp");
	    //strcpy (basedefault,DEVDATA"default.cfg");
        sprintf(wadfilename, "%s/doom1.wad", basedir);
	    return D_CheckWadFile(wadfilename);
    }

    // Check default wadfiles
    for(int i = 0; i < sizeof(d_wadnames) / sizeof(char*); i++){
        sprintf(wadfilename, "%s/%s", basedir, d_wadnames[i]);
        gm = D_CheckWadFile(wadfilename);
        if (gm != indetermined) {
		    return gm;   
        }
    }

    return indetermined;
}

//
// D_DoomMain
//
void D_DoomMain (int argc, char **argv)
{
    COM_Init(argc, argv);

    basedir = COM_GetParm("-basedir");
    
    if(!basedir){
        basedir = "/";
    }
    
    gamemode = D_IDVersion ();

    // Version select
    if(gamemode == indetermined){
        COM_Print("D_main: no wad file found");
        exit(-1);
    }

    modifiedgame = ga_nothing;
	
	// hacks ???
    nomonsters  = COM_CheckParm("-nomonsters");
    respawnparm = COM_CheckParm("-respawn");
    fastparm    = COM_CheckParm("-fast");
    d_devparm   = COM_CheckParm("-devparm");  
	autostart   = COM_CheckParm("-autostart");	

    if(gamemode == shareware){
        COM_Print ("DOOM Shareware Startup v%u.%u\n",
		            VERSION_NUM/100,VERSION_NUM%100);
    }
    
	/* turbo option */
	char *turbo = COM_GetParm("-turbo"); // -turbo <10-400>
    if (turbo)
    {
	   int     scale = atoi(turbo);;
	   extern int forwardmove[2];
	   extern int sidemove[2];

        if (scale < 10)
    	    scale = 10;

        if (scale > 400)
            scale = 400;

        printf ("turbo scale: %i%%\n",scale);
        forwardmove[0] = forwardmove[0]*scale/100;
        forwardmove[1] = forwardmove[1]*scale/100;
        sidemove[0] = sidemove[0]*scale/100;
    	sidemove[1] = sidemove[1]*scale/100;
    }    
   
    // init subsystems
    COM_Print ("V_Init: allocate screens.\n");
    V_Init ();

    COM_Print ("M_LoadDefaults: Load system defaults.\n");
    M_LoadDefaults ();              // load before initing other systems

    COM_Print ("Z_Init: Init zone memory allocation daemon. \n");
    Z_Init ();

    COM_Print ("W_Init: Init WADfiles.\n");    
    W_AddFile(wadfilename);

    COM_Print ("M_Init: Init miscellaneous info.\n");
    M_Init ();

    COM_Print ("R_Init: Init DOOM refresh daemon - ");
    R_Init ();

    COM_Print ("\nP_Init: Init Playloop state.\n");
    P_Init ();

    COM_Print ("I_Init: Setting up machine state.\n");
    I_Init ();

    COM_Print ("D_CheckNetGame: Checking network game status.\n");
    D_CheckNetGame ();

    COM_Print ("S_Init: Setting up sound.\n");
    S_Init (snd_SfxVolume, snd_MusicVolume);

    COM_Print ("HU_Init: Setting up heads up display.\n");
    HU_Init ();

    COM_Print ("ST_Init: Init status bar.\n");
    ST_Init ();
        
    if ( gameaction != ga_loadgame )
    {
        if (autostart || netgame)        
            G_InitNew (startskill, startepisode, startmap); // start directely on level one
        else
            D_StartTitle ();                // start up intro loop
    }

    D_DoomLoop ();
}
